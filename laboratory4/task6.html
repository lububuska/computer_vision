<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Canny JS</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    .row {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
    }
    .col {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    canvas {
      border: 1px solid #ccc;
    }
  </style>
</head>

<body>
<h2>Детекция границ Canny </h2>

<div class="row">
  <div class="col">
    <h3>Исходное изображение</h3>
    <canvas id="original"></canvas>
  </div>

  <div class="col">
    <h3>Example 1</h3>
    <canvas id="ex1"></canvas>
  </div>
</div>
<div class="row">
    <div class="col">
      <h3>Example 2</h3>
      <canvas id="ex2"></canvas>
    </div>
  
    <div class="col">
      <h3>Example 3</h3>
      <canvas id="ex3"></canvas>
    </div>
</div>

<script>
/* -------------------------------------------------------------------
   1. Грузим изображение и запускаем Canny
------------------------------------------------------------------- */
const img = new Image();
img.src = "cat_meme.webp";
img.onload = () => {
    const W = 480, H = 360;

    const canvases = {
        original: document.getElementById("original"),
        ex1: document.getElementById("ex1"),
        ex2: document.getElementById("ex2"),
        ex3: document.getElementById("ex3"),
    };

    for (const c of Object.values(canvases)) {
        c.width = W;
        c.height = H;
    }

    const ctx = canvases.original.getContext("2d");
    ctx.drawImage(img, 0, 0, W, H);

    const gray = getGrayscale(ctx, W, H);

    drawResult(canvases.ex1, canny(gray, W, H, 3, 3, 0.15, 0.5));
    drawResult(canvases.ex2, canny(gray, W, H, 3, 1, 0.2, 0.4));
    drawResult(canvases.ex3, canny(gray, W, H, 3, 1, 0.15, 0.35));
};


/* -------------------------------------------------------------------
   2. Функции рисования и конвертации
------------------------------------------------------------------- */
function getGrayscale(ctx, W, H) {
    const imgData = ctx.getImageData(0, 0, W, H);
    const arr = new Float32Array(W * H);

    for (let i = 0; i < W * H; i++) {
        const r = imgData.data[i*4];
        const g = imgData.data[i*4+1];
        const b = imgData.data[i*4+2];
        arr[i] = 0.299*r + 0.587*g + 0.114*b;
    }
    return arr;
}

function drawResult(canvas, arr) {
    const W = canvas.width, H = canvas.height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.createImageData(W, H);

    for (let i = 0; i < W*H; i++) {
        const v = arr[i];
        imgData.data[i*4] = v;
        imgData.data[i*4+1] = v;
        imgData.data[i*4+2] = v;
        imgData.data[i*4+3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);
}


/* -------------------------------------------------------------------
   3. Реализация Gaussian + Sobel + NMS + thresholds + hysteresis
------------------------------------------------------------------- */
function canny(image, W, H, kernelSize, sigma, highStep, lowStep) {

    const blurred = gaussianBlur(image, W, H, kernelSize, sigma);

    const {gx, gy, mag, angle} = sobel(blurred, W, H);

    const suppressed = nms(mag, angle, W, H);

    const result = thresholds(suppressed, W, H, highStep, lowStep);

    return result;
}


/* -------------------------------------------------------------------
   3.1 Gaussian
------------------------------------------------------------------- */
function gaussianKernel(size, sigma) {
    const k = new Float32Array(size * size);
    const half = size >> 1;

    let sum = 0;
    const s2 = 2 * sigma * sigma;

    let t = 0;
    for (let y = -half; y <= half; y++) {
        for (let x = -half; x <= half; x++, t++) {
            const v = Math.exp(-(x*x + y*y) / s2);
            k[t] = v;
            sum += v;
        }
    }
    for (let i = 0; i < k.length; i++) k[i] /= sum;
    return k;
}

function gaussianBlur(image, W, H, size, sigma) {
    const k = gaussianKernel(size, sigma);
    const half = size >> 1;
    const out = new Float32Array(W * H);

    for (let y = half; y < H - half; y++) {
        for (let x = half; x < W - half; x++) {

            let sum = 0;
            let t = 0;

            for (let ky = -half; ky <= half; ky++) {
                for (let kx = -half; kx <= half; kx++, t++) {
                    sum += image[(y+ky)*W + (x+kx)] * k[t];
                }
            }

            out[y*W + x] = sum;
        }
    }
    return out;
}


/* -------------------------------------------------------------------
   3.2 Sobel
------------------------------------------------------------------- */
const SOBEL_X = [-1,0,1,-2,0,2,-1,0,1];
const SOBEL_Y = [-1,-2,-1,0,0,0,1,2,1];

function sobel(img, W, H) {
    const gx = new Float32Array(W*H);
    const gy = new Float32Array(W*H);
    const mag = new Float32Array(W*H);
    const angle = new Float32Array(W*H);

    for (let y = 1; y < H-1; y++) {
        for (let x = 1; x < W-1; x++) {
            let sx = 0, sy = 0;
            let t = 0;

            for (let ky=-1; ky<=1; ky++) {
                for (let kx=-1; kx<=1; kx++, t++) {
                    const v = img[(y+ky)*W + (x+kx)];
                    sx += v * SOBEL_X[t];
                    sy += v * SOBEL_Y[t];
                }
            }

            gx[y*W + x] = sx;
            gy[y*W + x] = sy;

            const m = Math.sqrt(sx*sx + sy*sy);
            mag[y*W + x] = m;

            const a = Math.atan2(sy, sx) * 180 / Math.PI;
            angle[y*W + x] = (a + 180) % 180;
        }
    }
    return {gx, gy, mag, angle};
}


/* -------------------------------------------------------------------
   3.3 NMS (подавление немаксимумов)
------------------------------------------------------------------- */
function nms(mag, angle, W, H) {
    const out = new Float32Array(W*H);

    for (let y = 1; y < H-1; y++) {
        for (let x = 1; x < W-1; x++) {

            const a = angle[y*W + x];
            const m = mag[y*W + x];
            let m1 = 0, m2 = 0;

            if ((a >= 0 && a < 22.5) || (a >= 157.5 && a < 180)) {
                m1 = mag[y*W + (x+1)];
                m2 = mag[y*W + (x-1)];
            }
            else if (a >= 22.5 && a < 67.5) {
                m1 = mag[(y+1)*W + (x-1)];
                m2 = mag[(y-1)*W + (x+1)];
            }
            else if (a >= 67.5 && a < 112.5) {
                m1 = mag[(y+1)*W + x];
                m2 = mag[(y-1)*W + x];
            }
            else {
                m1 = mag[(y-1)*W + (x-1)];
                m2 = mag[(y+1)*W + (x+1)];
            }

            out[y*W + x] = (m >= m1 && m >= m2) ? m : 0;
        }
    }
    return out;
}


/* -------------------------------------------------------------------
   3.4 Thresholds + Hysteresis
------------------------------------------------------------------- */
function thresholds(img, W, H, highStep, lowStep) {
    const out = new Uint8ClampedArray(W*H);

    // --------------------------
    // Find max without spread !!!
    // --------------------------
    let max = 0;
    for (let i = 0; i < img.length; i++) {
        if (img[i] > max) max = img[i];
    }

    const high = highStep * max;
    const low = lowStep * high;

    const STRONG = 255;
    const WEAK = 50;

    // classify pixels
    for (let i = 0; i < W*H; i++) {
        const v = img[i];
        out[i] = v >= high ? STRONG :
                 v >= low  ? WEAK :
                 0;
    }

    // hysteresis
    let changed = true;

    while (changed) {
        changed = false;

        for (let y = 1; y < H - 1; y++) {
            for (let x = 1; x < W - 1; x++) {
                const idx = y * W + x;

                if (out[idx] === WEAK) {

                    if (
                        out[idx - W - 1] === STRONG ||
                        out[idx - W]     === STRONG ||
                        out[idx - W + 1] === STRONG ||
                        out[idx + 1]     === STRONG ||
                        out[idx + W + 1] === STRONG ||
                        out[idx + W]     === STRONG ||
                        out[idx + W - 1] === STRONG ||
                        out[idx - 1]     === STRONG
                    ) {
                        out[idx] = STRONG;
                        changed = true;
                    } else {
                        out[idx] = 0;
                    }
                }
            }
        }
    }

    return out;
}

</script>
</body>
</html>
